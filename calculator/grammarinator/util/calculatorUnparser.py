# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import calculatorUnlexer


class calculatorUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(calculatorUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def equation(self):
        current = self.create_node(UnparserRule(name='equation'))
        current += self.expression()
        current += self.relop()
        current += self.expression()
        current += self.unlexer.EOF()
        return current
    equation.min_depth = 7

    @depthcontrol
    def expression(self):
        current = self.create_node(UnparserRule(name='expression'))
        current += self.multiplyingExpression()
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_47', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_47', choice)] = self.unlexer.weights.get(('alt_47', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.PLUS()
                elif choice == 1:
                    current += self.unlexer.MINUS()
                current += self.multiplyingExpression()

        return current
    expression.min_depth = 6

    @depthcontrol
    def multiplyingExpression(self):
        current = self.create_node(UnparserRule(name='multiplyingExpression'))
        current += self.powExpression()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_51', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_51', choice)] = self.unlexer.weights.get(('alt_51', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.TIMES()
                elif choice == 1:
                    current += self.unlexer.DIV()
                current += self.powExpression()

        return current
    multiplyingExpression.min_depth = 5

    @depthcontrol
    def powExpression(self):
        current = self.create_node(UnparserRule(name='powExpression'))
        current += self.signedAtom()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.unlexer.POW()
                current += self.signedAtom()

        return current
    powExpression.min_depth = 4

    @depthcontrol
    def signedAtom(self):
        current = self.create_node(UnparserRule(name='signedAtom'))
        choice = self.choice([0 if [4, 4, 8, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_55', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_55', choice)] = self.unlexer.weights.get(('alt_55', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.PLUS()
            current += self.signedAtom()
        elif choice == 1:
            current += self.unlexer.MINUS()
            current += self.signedAtom()
        elif choice == 2:
            current += self.func_()
        elif choice == 3:
            current += self.atom()
        return current
    signedAtom.min_depth = 3

    @depthcontrol
    def atom(self):
        current = self.create_node(UnparserRule(name='atom'))
        choice = self.choice([0 if [3, 3, 2, 7][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_60', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_60', choice)] = self.unlexer.weights.get(('alt_60', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.scientific()
        elif choice == 1:
            current += self.variable()
        elif choice == 2:
            current += self.constant()
        elif choice == 3:
            current += self.unlexer.LPAREN()
            current += self.expression()
            current += self.unlexer.RPAREN()
        return current
    atom.min_depth = 2

    @depthcontrol
    def scientific(self):
        current = self.create_node(UnparserRule(name='scientific'))
        current += self.unlexer.SCIENTIFIC_NUMBER()
        return current
    scientific.min_depth = 2

    @depthcontrol
    def constant(self):
        current = self.create_node(UnparserRule(name='constant'))
        choice = self.choice([0 if [1, 2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_65', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_65', choice)] = self.unlexer.weights.get(('alt_65', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.PI()
        elif choice == 1:
            current += self.unlexer.EULER()
        elif choice == 2:
            current += self.unlexer.I()
        return current
    constant.min_depth = 1

    @depthcontrol
    def variable(self):
        current = self.create_node(UnparserRule(name='variable'))
        current += self.unlexer.VARIABLE()
        return current
    variable.min_depth = 2

    @depthcontrol
    def func_(self):
        current = self.create_node(UnparserRule(name='func_'))
        current += self.funcname()
        current += self.unlexer.LPAREN()
        current += self.expression()
        if self.unlexer.max_depth >= 7:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.expression()

        current += self.unlexer.RPAREN()
        return current
    func_.min_depth = 7

    @depthcontrol
    def funcname(self):
        current = self.create_node(UnparserRule(name='funcname'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_70', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_70', choice)] = self.unlexer.weights.get(('alt_70', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.COS()
        elif choice == 1:
            current += self.unlexer.TAN()
        elif choice == 2:
            current += self.unlexer.SIN()
        elif choice == 3:
            current += self.unlexer.ACOS()
        elif choice == 4:
            current += self.unlexer.ATAN()
        elif choice == 5:
            current += self.unlexer.ASIN()
        elif choice == 6:
            current += self.unlexer.LOG()
        elif choice == 7:
            current += self.unlexer.LN()
        elif choice == 8:
            current += self.unlexer.SQRT()
        return current
    funcname.min_depth = 1

    @depthcontrol
    def relop(self):
        current = self.create_node(UnparserRule(name='relop'))
        choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_80', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_80', choice)] = self.unlexer.weights.get(('alt_80', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.EQ()
        elif choice == 1:
            current += self.unlexer.GT()
        elif choice == 2:
            current += self.unlexer.LT()
        return current
    relop.min_depth = 1

    default_rule = equation

