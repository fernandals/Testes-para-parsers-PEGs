# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

charset_0 = list(chain(range(32, 33), range(13, 14), range(10, 11), range(9, 10)))


class calculatorUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(calculatorUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def COS(self):
        current = self.create_node(UnlexerRule(name='COS'))
        current += self.create_node(UnlexerRule(src='cos'))
        return current
    COS.min_depth = 0

    @depthcontrol
    def SIN(self):
        current = self.create_node(UnlexerRule(name='SIN'))
        current += self.create_node(UnlexerRule(src='sin'))
        return current
    SIN.min_depth = 0

    @depthcontrol
    def TAN(self):
        current = self.create_node(UnlexerRule(name='TAN'))
        current += self.create_node(UnlexerRule(src='tan'))
        return current
    TAN.min_depth = 0

    @depthcontrol
    def ACOS(self):
        current = self.create_node(UnlexerRule(name='ACOS'))
        current += self.create_node(UnlexerRule(src='acos'))
        return current
    ACOS.min_depth = 0

    @depthcontrol
    def ASIN(self):
        current = self.create_node(UnlexerRule(name='ASIN'))
        current += self.create_node(UnlexerRule(src='asin'))
        return current
    ASIN.min_depth = 0

    @depthcontrol
    def ATAN(self):
        current = self.create_node(UnlexerRule(name='ATAN'))
        current += self.create_node(UnlexerRule(src='atan'))
        return current
    ATAN.min_depth = 0

    @depthcontrol
    def LN(self):
        current = self.create_node(UnlexerRule(name='LN'))
        current += self.create_node(UnlexerRule(src='ln'))
        return current
    LN.min_depth = 0

    @depthcontrol
    def LOG(self):
        current = self.create_node(UnlexerRule(name='LOG'))
        current += self.create_node(UnlexerRule(src='log'))
        return current
    LOG.min_depth = 0

    @depthcontrol
    def SQRT(self):
        current = self.create_node(UnlexerRule(name='SQRT'))
        current += self.create_node(UnlexerRule(src='sqrt'))
        return current
    SQRT.min_depth = 0

    @depthcontrol
    def LPAREN(self):
        current = self.create_node(UnlexerRule(name='LPAREN'))
        current += self.create_node(UnlexerRule(src='('))
        return current
    LPAREN.min_depth = 0

    @depthcontrol
    def RPAREN(self):
        current = self.create_node(UnlexerRule(name='RPAREN'))
        current += self.create_node(UnlexerRule(src=')'))
        return current
    RPAREN.min_depth = 0

    @depthcontrol
    def PLUS(self):
        current = self.create_node(UnlexerRule(name='PLUS'))
        current += self.create_node(UnlexerRule(src='+'))
        return current
    PLUS.min_depth = 0

    @depthcontrol
    def MINUS(self):
        current = self.create_node(UnlexerRule(name='MINUS'))
        current += self.create_node(UnlexerRule(src='-'))
        return current
    MINUS.min_depth = 0

    @depthcontrol
    def TIMES(self):
        current = self.create_node(UnlexerRule(name='TIMES'))
        current += self.create_node(UnlexerRule(src='*'))
        return current
    TIMES.min_depth = 0

    @depthcontrol
    def DIV(self):
        current = self.create_node(UnlexerRule(name='DIV'))
        current += self.create_node(UnlexerRule(src='/'))
        return current
    DIV.min_depth = 0

    @depthcontrol
    def GT(self):
        current = self.create_node(UnlexerRule(name='GT'))
        current += self.create_node(UnlexerRule(src='>'))
        return current
    GT.min_depth = 0

    @depthcontrol
    def LT(self):
        current = self.create_node(UnlexerRule(name='LT'))
        current += self.create_node(UnlexerRule(src='<'))
        return current
    LT.min_depth = 0

    @depthcontrol
    def EQ(self):
        current = self.create_node(UnlexerRule(name='EQ'))
        current += self.create_node(UnlexerRule(src='='))
        return current
    EQ.min_depth = 0

    @depthcontrol
    def COMMA(self):
        current = self.create_node(UnlexerRule(name='COMMA'))
        current += self.create_node(UnlexerRule(src=','))
        return current
    COMMA.min_depth = 0

    @depthcontrol
    def POINT(self):
        current = self.create_node(UnlexerRule(name='POINT'))
        current += self.create_node(UnlexerRule(src='.'))
        return current
    POINT.min_depth = 0

    @depthcontrol
    def POW(self):
        current = self.create_node(UnlexerRule(name='POW'))
        current += self.create_node(UnlexerRule(src='^'))
        return current
    POW.min_depth = 0

    @depthcontrol
    def PI(self):
        current = self.create_node(UnlexerRule(name='PI'))
        current += self.create_node(UnlexerRule(src='pi'))
        return current
    PI.min_depth = 0

    @depthcontrol
    def EULER(self):
        current = self.create_node(UnlexerRule(name='EULER'))
        current += self.unlexer.E2()
        return current
    EULER.min_depth = 1

    @depthcontrol
    def I(self):
        current = self.create_node(UnlexerRule(name='I'))
        current += self.create_node(UnlexerRule(src='i'))
        return current
    I.min_depth = 0

    @depthcontrol
    def VARIABLE(self):
        current = self.create_node(UnlexerRule(name='VARIABLE'))
        current += self.unlexer.VALID_ID_START()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.VALID_ID_CHAR()

        return current
    VARIABLE.min_depth = 1

    @depthcontrol
    def VALID_ID_START(self):
        current = self.create_node(UnlexerRule(name='VALID_ID_START'))
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_24', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_24', choice)] = self.unlexer.weights.get(('alt_24', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(97, 123))))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(65, 91))))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='_'))
        return current
    VALID_ID_START.min_depth = 0

    @depthcontrol
    def VALID_ID_CHAR(self):
        current = self.create_node(UnlexerRule(name='VALID_ID_CHAR'))
        choice = self.choice([0 if [1, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_29', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_29', choice)] = self.unlexer.weights.get(('alt_29', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.VALID_ID_START()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 58))))
        return current
    VALID_ID_CHAR.min_depth = 0

    @depthcontrol
    def SCIENTIFIC_NUMBER(self):
        current = self.create_node(UnlexerRule(name='SCIENTIFIC_NUMBER'))
        current += self.unlexer.NUMBER()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_33', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_33', choice)] = self.unlexer.weights.get(('alt_33', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.E1()
                elif choice == 1:
                    current += self.unlexer.E2()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SIGN()

                current += self.unlexer.NUMBER()

        return current
    SCIENTIFIC_NUMBER.min_depth = 1

    @depthcontrol
    def NUMBER(self):
        current = self.create_node(UnlexerRule(name='NUMBER'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 58))))

        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='.'))
                if self.unlexer.max_depth >= 0:
                    for _ in self.one_or_more():
                        current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 58))))


        return current
    NUMBER.min_depth = 0

    @depthcontrol
    def E1(self):
        current = self.create_node(UnlexerRule(name='E1'))
        current += self.create_node(UnlexerRule(src='E'))
        return current
    E1.min_depth = 0

    @depthcontrol
    def E2(self):
        current = self.create_node(UnlexerRule(name='E2'))
        current += self.create_node(UnlexerRule(src='e'))
        return current
    E2.min_depth = 0

    @depthcontrol
    def SIGN(self):
        current = self.create_node(UnlexerRule(name='SIGN'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_41', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_41', choice)] = self.unlexer.weights.get(('alt_41', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='+'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='-'))
        return current
    SIGN.min_depth = 0

    @depthcontrol
    def WS(self):
        current = self.create_node(UnlexerRule(name='WS'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_0)))

        return current
    WS.min_depth = 0

